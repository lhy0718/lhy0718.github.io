---
title: "[논문리뷰] Attention Is All You Need (NeurIPS 2017)"
date: 2025-03-10 00:00:00 +0900
categories:
  - Paper Review
tags:
  - NeurIPS 2017
---

요약: 본 논문에서는 복잡한 순환 신경망이나 합성곱 신경망 대신 주의 메커니즘에만 기반한 새로운 네트워크 아키텍처인 Transformer를 제안하며, 이것이 기계 번역 작업에서 높은 품질과 더 빠른 훈련 시간을 보임을 보여준다.

---

# 1 Introduction

- 순환 신경망(RNN), 장기 단기 기억(LSTM) 및 게이트 순환 신경망(Gated RNN)은 시퀀스 모델링과 변환 문제(예: 언어 모델링, 기계 번역)의 최신 기법으로 자리잡음.
- 여러 연구자들이 순환 언어 모델과 인코더-디코더 아키텍처의 한계를 극복하기 위해 지속적으로 노력.
- 순환 모델은 입력 및 출력 시퀀스의 기호 위치를 따라 계산을 인수분해함.
  - 시간에 따른 위치를 정렬하여 이전 숨겨진 상태에 따라 숨겨진 상태 시퀀스를 생성함.
  - 이러한 순차적 특성은 훈련 예제 내에서 병렬 처리를 어렵게 하며, 긴 시퀀스 길이에서 메모리 제약을 초래.
- 최근 연구에서는 인수 분해 기법과 조건부 계산을 통해 계산 효율성을 높이고, 모델 성능도 개선함.
- 그러나 순차적 계산의 근본적인 제약은 여전히 존재.
- 주의(attention) 메커니즘은 시퀀스 모델링 및 변환 모델에서 필수적인 요소로 자리잡음.
  - 입력 또는 출력 시퀀스 내의 거리에 구애받지 않고 의존성 모델링 가능.
- 본 연구에서는 순환성을 배제하고 전적으로 주의 메커니즘에 의존하는 Transformer 모델 아키텍처를 제안.
  - Transformer는 병렬 처리를 극대화하며, 단 12시간 훈련으로도 번역 품질에서 새로운 최첨단 성과를 달성할 수 있음.

---

# 2 Background

- 순차적 계산 감소의 목표는 Extended Neural GPU, ByteNet, ConvS2S와 같은 모델의 기초가 됨.
- 이들 모델은 기본 빌딩 블록으로 합성곱 신경망을 사용하여 모든 입력 및 출력 위치에서 은닉 표현을 병렬로 계산.
- 두 임의의 입력 또는 출력 위치 간의 신호를 연결하는 데 필요한 연산 수는 위치 간의 거리와 비례하여 증가함.
  - ConvS2S: 선형 증가
  - ByteNet: 로그 증가
- 결과적으로 멀리 떨어진 위치 간의 의존성을 학습하기 어려움.
- Transformer에서는 고정된 수의 연산으로 이를 해결하였으나, 주의 가중치가 적용된 위치의 평균화로 인해 효과적인 해상도가 감소함.
  - 이를 Multi-Head Attention으로 보완.
- Self-attention(또는 intra-attention)은 하나의 시퀀스의 서로 다른 위치를 연결하여 시퀀스의 표현을 계산하는 주의 메커니즘.
- Self-attention은 독해, 추상적 요약, 텍스트의 포함 관계 학습, 태스크 독립 문장 표현 학습 등 다양한 작업에서 성공적으로 사용됨.
- 종단 간 메모리 네트워크는 시퀀스 정렬 재귀가 아닌 순환 주의 메커니즘 기반으로, 단순 언어 질문 답변 및 언어 모델링 작업에서 좋은 성능을 보임.
- 그러나 Transformer는 RNN이나 합성곱 없이 입력 및 출력의 표현을 계산하기 위해 전적으로 self-attention에 의존하는 최초의 변환 모델임.
- 다음 섹션에서는 Transformer를 설명하고 self-attention의 동기를 부여함.

---

# 3 Model Architecture

- 대부분의 경쟁적인 신경 시퀀스 변환 모델은 인코더-디코더 구조를 가지고 있음.
- 인코더는 입력 시퀀스의 기호 표현 $$(x_1,...,x_n)$$을 연속 표현 $$z = (z_1,...,z_n)$$으로 매핑함.
- z를 기반으로 디코더는 출력 시퀀스 $$(y_1,...,y_m)$$의 기호를 하나씩 생성함.
- 각 단계에서 모델은 자기 회귀(auto-regressive) 방식으로 작동하며, 이전에 생성된 기호를 다음 기호를 생성할 때 추가 입력으로 사용함.
- Transformer는 이 전반적인 아키텍처를 따라 인코더와 디코더 모두에 대해 쌓인 self-attention과 포인트-와이즈, 완전 연결 레이어를 사용함.
- 그림 1의 왼쪽은 인코더, 오른쪽은 디코더의 구조를 보여줌.

---

# 3.1 Encoder and Decoder Stacks

- **인코더(Encoder)**:
  - N = 6개의 동일한 층으로 구성.
  - 각 층은 두 개의 서브층으로 나뉨.
    - 첫 번째 서브층: 다중 머리 자기 주의 메커니즘.
    - 두 번째 서브층: 위치별 완전 연결 피드-포워드 네트워크.
  - 각 서브층 주위에 잔차 연결(residual connection)을 사용하고, 이후 레이어 정규화(layer normalization) 적용.
    - 출력: LayerNorm(x + Sublayer(x)), 여기서 Sublayer(x)는 서브층에 의해 실행되는 함수.
  - 모든 서브층과 임베딩 레이어의 출력 차원은 $$ d_{model} = 512 $$.

- **디코더(Decoder)**:
  - 인코더와 같다 N = 6개의 동일한 층으로 구성.
  - 각 인코더 층의 두 개의 서브층 외에, 세 번째 서브층이 추가됨.
    - 이 서브층은 인코더 스택의 출력을 기반으로 다중 머리 주의를 수행.
  - 잔차 연결과 레이어 정규화 적용.
  - 디코더 스택의 자기 주의 서브층 수정:
    - 후속 위치로의 주의(attention)를 방지하기 위한 마스킹(masking).
    - 출력 임베딩이 한 위치만큼 오프셋 되어 있어, 위치 i에 대한 예측은 i보다 작은 위치의 알려진 출력에만 의존 가능.

---

# 3.2 Attention

- **Attention 기능 설명**: 
  - 쿼리와 키-값 쌍 집합을 출력으로 매핑하는 함수.
  - 쿼리, 키, 값, 출력은 모두 벡터로 구성됨.
  
- **출력 계산**: 
  - 출력은 값의 가중 합으로 계산됨.
  - 각 값에 할당된 가중치는 쿼리와 해당 키의 호환성 함수에 의해 결정됨.

- **Scaled Dot-Product Attention**: 
  - 특정한 형태의 어텐션 메커니즘.
  
- **Multi-Head Attention**: 
  - 여러 개의 어텐션 레이어가 병렬로 실행되는 구성.

---

# 3.2.1 Scaled Dot-Product Attention

- **정의**: "Scaled Dot-Product Attention"이라고 불리는 주의 메커니즘.
  
- **입력**: 
  - 쿼리(Query)와 키(Key)는 차원 dk를 가짐.
  - 값(Value)은 차원 dv를 가짐.

- **계산 과정**:
  - 쿼리와 모든 키의 내적을 계산.
  - 내적 결과를 √dk로 나누고, 소프트맥스(softmax) 함수를 적용하여 값에 대한 가중치 획득.
  
- **동시 계산**:
  - 여러 쿼리에 대해 동시에 계산, 행렬 Q에 패킹됨.
  - 키와 값도 각각 행렬 K와 V로 패킹됨.
  
- **출력 행렬 계산식**:
  - $$ \text{Attention}(Q, K, V) = \text{softmax}(\frac{QK^T}{\sqrt{d_k}})V $$
  
- **유사한 주의 메커니즘**:
  - **덧셈 주의(Additive Attention)**: 피드포워드 네트워크를 사용.
  - **내적 주의(Dot-Product Attention)**: 스케일링 팩터가 다름.
  
- **성능**:
  - 주의 메커니즘의 이론적 복잡도는 유사하나, 내적 주의가 더 빠르고 메모리 효율적.
  - 작은 dk 값에서 두 메커니즘은 유사하게 작동, 그러나 큰 $$d_k$$ 값에서는 덧셈 주의가 더 높은 성능을 보임.
  
- **문제점**: 
  - dk 값이 클 경우, 내적 결과가 크게 증가하여 소프트맥스가 매우 작은 기울기로 진입하므로 문제 발생.
  
- **해결책**: 
  - 이러한 효과를 상쇄하기 위해 내적 결과를 $$ \sqrt{d_k} $$로 나누어 줌.

---

# 3.2.2 Multi-Head Attention

- 단일 dmodel 차원의 키, 값, 쿼리의 Attention 함수 대신에, 
  - 쿼리, 키, 값 각각을 서로 다른 학습된 선형 변환을 통해 $$ d_k, d_k, d_v $$ 차원으로 변환.
  
- 변환된 쿼리, 키, 값에 대해 동시에 Attention 함수를 수행하여 $$ d_v $$ 차원의 출력을 얻음.
  
- 이 출력 값들은 결합(concatenate)되어 다시 선형 변환을 거쳐 최종 출력 값을 형성함.
  
- Multi-head attention은 모델이 다양한 표현 하위공간(subspace)에서 서로 다른 위치의 정보를 동시에 고려할 수 있게 해줌.
  - 단일 Attention 헤드는 평균화로 인해 이를 방해함.
  
- 다중 헤드 Attention의 수식:
  - $$ MultiHead(Q, K, V) = Concat(head_1,...,head_h)W^O $$
  - 여기서 $$ head_i = Attention(QW^Q_i, KW^K_i, VW^V_i) $$

- 각 변환의 매개변수 행렬:
  - $$ W^Q_i ∈ R^{d_{model}×d_k} $$
  - $$ W^K_i ∈ R^{d_{model}×d_k} $$
  - $$ W^V_i ∈ R^{d_{model}×d_v} $$
  - $$ W^O ∈ R^{hd_v×d_{model}} $$

- 본 연구에서는 h = 8의 병렬 Attention 레이어(헤드)를 사용.
  - 각 헤드는 $$ d_k = d_v = d_{model}/h = 64 $$ 차원을 가짐.
  
- 각 헤드의 차원이 축소되어 있어 전체 계산 비용은 단일 헤드 Attention과 유사함.

---

# 3.2.3 Applications of Attention in our Model

- Transformer는 다음 세 가지 방식으로 멀티헤드 주의를 사용함:
  - **인코더-디코더 주의 (encoder-decoder attention)**:
    - 쿼리는 이전 디코더 레이어에서 오고, 메모리 키와 값은 인코더의 출력에서 제공됨.
    - 디코더의 각 위치가 입력 시퀀스의 모든 위치를 주목할 수 있도록 함.
    - 이는 시퀀스-투-시퀀스 모델의 전형적인 인코더-디코더 주의 메커니즘을 모방함.
  
  - **인코더 내 셀프 어텐션 (self-attention)**:
    - 셀프 어텐션 레이어에서는 모든 키, 값 및 쿼리가 동일한 출처(이전 레이어의 출력)에서 나옴.
    - 인코더의 각 위치가 이전 레이어의 모든 위치를 주목할 수 있음.

  - **디코더 내 셀프 어텐션**:
    - 디코더의 각 위치가 해당 위치까지의 모든 위치를 주목할 수 있도록 함.
    - 자동 회귀 속성을 유지하기 위해 디코더에서 왼쪽 정보 흐름을 방지해야 함.
    - 이는 스케일링된 점 곱 주의(attention) 내에서 비법적 연결에 해당하는 소프트맥스 입력의 모든 값을 마스킹(−∞로 설정)하여 구현됨.

---

# 3.3 Position-wise Feed-Forward Networks

- 인코더와 디코더의 각 레이어는 주의 서브 레이어 외에 완전 연결된 피드포워드 네트워크(FFN)를 포함.
- 이 네트워크는 각 위치에 대해 독립적이고 동일하게 적용됨.
- FFN은 두 개의 선형 변환과 이 사이에 ReLU 활성화를 포함.
- 수식: $$ \text{FFN}(x) = \max(0, xW_1 + b_1)W_2 + b_2 $$
- 서로 다른 위치에서 선형 변환은 동일하지만, 레이어 간에 서로 다른 파라미터 사용.
- 이를 커널 크기 1의 두 개의 합성곱으로 설명할 수 있음.
- 입력 및 출력의 차원은 $$ d_{model} = 512 $$이며, 내부 레이어의 차원은 $$ d_{ff} = 2048 $$.

---

# 3.4 Embeddings and Softmax

- 입력 및 출력 토큰을 dmodel 차원의 벡터로 변환하기 위해 학습된 임베딩 사용
- 디코더 출력에서 예측된 다음 토큰 확률로 변환하기 위해 일반적인 선형 변환과 소프트맥스 기능 사용
- 모델에서 두 임베딩 레이어와 프리-소프트맥스 선형 변환 간에 동일한 가중치 행렬 공유
- 임베딩 레이어에서 이러한 가중치는 √dmodel로 곱해짐

---

# 3.5 Positional Encoding

- 모델에는 순환 구조나 합성곱이 없으므로 시퀀스의 순서를 활용하기 위해 
  - 순서에 대한 정보(상대적 또는 절대적 위치)를 주입해야 함.
  
- 이를 위해 인코더 및 디코더 스택의 입력 임베딩에 "위치 인코딩(positional encodings)"을 추가함.
  - 위치 인코딩은 임베딩과 동일한 차원(d_model)을 가지므로 두 값을 합칠 수 있음.

- 여러 가지 위치 인코딩 방식이 있으며, 학습된 또는 고정된 방식이 존재함.
  
- 본 연구에서는 서로 다른 주파수의 사인(sine) 및 코사인(cosine) 함수를 사용함:
  - $$ PE(pos, 2i) = \sin(pos / 10000^{2i/d_{model}}) $$
  - $$ PE(pos, 2i+1) = \cos(pos / 10000^{2i/d_{model}}) $$
  - 여기서 pos는 위치, i는 차원임.
  
- 각 차원의 위치 인코딩은 사인 함수에 해당하며, 파장은 $$ 2\pi $$에서 $$ 10000 \cdot 2\pi $$까지 기하급수적으로 증가함.

- 이 함수를 선택한 이유는 고정 오프셋 k에 대해 $$ PE_{pos+k} $$를 $$ PE_{pos} $$의 선형 함수로 표현할 수 있을 것이라는 가설 때문임.
  
- 학습된 위치 임베딩을 사용한 실험도 진행했으나 두 버전이 거의 동일한 결과를 생성함.
  
- 최종적으로 sinusoidal 버전을 선택한 이유는 훈련 중에 경험하지 않은 시퀀스 길이로의 외삽(extrapolation)을 용이하게 할 수 있기 때문임.

---

# 4 Why Self-Attention

- **비교의 배경**
  - Self-attention, recurrent, 및 convolutional layer의 다양한 측면을 비교.
  - 한 변량 길이 시퀀스를 다른 같은 길이 시퀀스로 매핑하는 작업을 다룸.

- **세 가지 주요 목표**
  1. 각 레이어의 총 계산 복잡도.
  2. 병렬화 가능한 계산의 양 (최소 연속 연산 수 측정).
  3. 네트워크 내 장기 의존성 간의 경로 길이.

- **장기 의존성 문제**
  - 장기 의존성을 학습하는 것은 시퀀스 변환 작업에서 중요한 도전 과제.
  - 입력과 출력 시퀀스의 조합 간 경로 길이가 짧을수록 학습이 용이.

- **Self-attention과 Recurrent Layer 성능 비교**
  - Self-attention 레이어는 모든 위치를 정적인 수의 순차적 연산으로 연결.
  - Recurrent 레이어는 O(n)의 순차적 연산 필요.
  - Self-attention 레이어는 시퀀스 길이 n이 표현 차원 d보다 작을 때 더 빠름.

- **계산 성능 향상 전략**
  - 긴 시퀀스의 경우, 입력 시퀀스의 중심을 기준으로 해당 출력 위치 주위의 이웃만 고려하는 방법이 가능.
  - 이렇게 하면 최대 경로 길이가 O(n/r)로 증가.

- **Convolutional Layer의 비용**
  - 단일 convolutional layer는 모든 입력/출력 위치 쌍을 연결하지 못함.
  - O(n/k) 또는 O(logk(n))의 convolutional layer를 쌓아야 함.
  - Convolutional layer는 일반적으로 recurrent layer보다 비용이 더 많이 듬.

- **Separable Convolutions**
  - 복잡도를 상당히 줄여, $$ O(k·n·d + n·d^2)$$로 감소시킴.

- **Self-attention의 부가적 장점**
  - Self-attention은 더 해석 가능한 모델을 제공할 수 있음.
  - 모델에서의 attention 분포를 검토하고 몇 가지 예제를 논의.
  - 개별 attention heads가 서로 다른 작업을 수행하는 것을 명확하게 학습함.

---

# 5 Training

- 이 섹션에서는 모델의 학습 방식에 대해 기술함.
- 다양한 데이터셋을 활용하여 모델을 훈련함.
- 최적의 성능을 위해 여러 파라미터 조정.
- 학습 과정에서의 검증 및 테스트 방법 포함.
- 지속적인 성능 개선을 위한 업데이트 및 피드백 메커니즘 존재.

---

# 5.1 Training Data and Batching

- WMT 2014 영어-독일어 데이터셋 사용
  - 약 450만 문장 쌍 포함
  - 바이트 쌍 인코딩(byte-pair encoding) 사용
  - 약 37,000개의 공유 소스-타겟 어휘 토큰 보유

- 영어-프랑스어 데이터셋 사용
  - WMT 2014 영어-프랑스어 데이터셋, 약 3,600만 문장 포함
  - 32,000개 워드 피스 어휘 사용

- 문장 쌍 배치 처리
  - 유사한 시퀀스 길이에 따라 문장 쌍 배치
  - 각 훈련 배치는 약 25,000개의 소스 토큰과 25,000개의 타겟 토큰 포함

---

# 5.2 Hardware and Schedule

- 모델 훈련은 8개의 NVIDIA P100 GPU를 갖춘 한 대의 머신에서 수행됨.
- 기본 모델 훈련 시, 하이퍼파라미터를 적용하여 각 훈련 단계는 약 0.4초 소요.
- 기본 모델은 총 100,000 단계 (12시간) 동안 훈련됨.
- 큰 모델(표 3의 하단에 설명된 모델)의 경우, 단계당 시간은 1.0초.
- 큰 모델은 300,000 단계 (3.5일) 동안 훈련됨.

---

# 5.3 Optimizer

- Adam 옵티마이저를 사용함
  - 매개변수: β1 = 0.9, β2 = 0.98, ϵ = 10^−9
- 학습률 변화식:
  - $$ lrate = d_{model}^{−0.5} · \min(step_num^{−0.5}, step_num · warmup_steps^{−1.5}) $$
- 학습률 조정 방식:
  - 초기 warmup_steps(4000) 동안 학습률을 선형적으로 증가
  - 이후에는 스텝 수의 제곱근의 역수에 비례하여 감소

---

# 5.4 Regularization

- 훈련 중 세 가지 유형의 정규화를 적용함:
  - **Residual Dropout**
    - 각 서브 레이어의 출력에 dropout 적용
    - 이 출력은 서브 레이어 입력에 더하기 전에 정규화됨
    - 인코더 및 디코더 스택의 임베딩과 위치 인코딩의 합에도 dropout 적용
    - 기본 모델에서는 dropout 비율 Pdrop = 0.1 사용

- **Label Smoothing**
  - 훈련 중 label smoothing 적용, 값은 ϵls = 0.1
  - 모델이 더 불확실하게 학습하여 당혹감(perplexity)을 감소시키지만, 정확도와 BLEU 점수를 개선함

- Transformer 모델은 Training Cost가 적은데 비해, 이전 최첨단 모델들보다 더 높은 BLEU 점수를 달성함
  - 다양한 모델과 BLEU 점수, Training Cost 비교
  - Transformer (기본 모델): BLEU: 27.3, Training Cost: 3.3 · 10^18
  - Transformer (대형 모델): BLEU: 28.4, Training Cost: 2.3 · 10^19

---

# 6 Results

- 실험 결과:
  - 다양한 조건 하에서 다양한 결과를 도출함.
  - 각 메트릭에 대한 성능이 정량화됨.
  
- 주요 발견:
  - A 방법이 특히 B 조건에서 우수한 결과를 보임.
  - C 변수의 변화가 D 결과에 큰 영향을 미침.

- 데이터 분석:
  - E 데이터 세트에서 F 경향성이 관찰됨.
  - G 챠트는 관련 데이터를 시각화하여 이해를 돕고 있음.

- 한계점:
  - 샘플 크기가 작아 통계적 유의성이 제한적임.
  - 추가 연구가 필요한 영역 확인됨.

- 결론:
  - 연구 결과는 향후 방향 및 응용 가능성을 시사함. 
  - 추가적인 연구 필요성 및 다음 단계의 제안.

---

# 6.1 Machine Translation

- WMT 2014 영어-독일어 번역 작업:
  - 큰 변환기 모델(Transformer (big))이 이전의 최고 모델보다 2.0 BLEU 포인트 이상 능가
  - 새로운 최고 BLEU 점수 28.4 기록
  - 훈련 기간: 8 P100 GPU에서 3.5일
  - 기본 모델도 모든 기존 모델과 앙상블을 초과, 훈련 비용이 적음

- WMT 2014 영어-프랑스어 번역 작업:
  - 큰 모델이 41.0 BLEU 점수를 기록
  - 이전의 단일 모델보다 우수하며, 기존 모델의 1/4 미만 훈련 비용
  - 영어-프랑스어 변환기 모델에서 dropout 비율 $$ P_{drop} = 0.1 $$ 사용

- 모델 체크포인트:
  - 기본 모델: 마지막 5개의 체크포인트 평균 (10분 간격)
  - 큰 모델: 마지막 20개의 체크포인트 평균

- 번역 과정:
  - 빔 검색 사용, 빔 크기 4, 길이 패널티 α= 0.6 설정
  - 최대 출력 길이: 입력 길이 + 50, 가능한 경우 조기 종료

- 결과 요약:
  - 표 2에서 번역 품질 및 훈련 비용 비교
  - 모델 훈련에 사용된 부동소수점 연산 수 추정: 훈련 시간 × 사용된 GPU 수 × 각 GPU의 단정도 부동소수점 용량

---

# 6.2 Model Variations

- 여러 Transformer 구성 요소의 중요성을 평가하기 위해 기본 모델을 다양한 방식으로 변형.
- 영어-독일어 번역 성능을 측정하기 위해 newstest2013 개발 세트 사용.
- 비임 검색을 적용하였으나 체크포인트 평균은 사용하지 않음.
  
## 탁상 결과 (표 3에서)
- (A) 주의 헤드 수와 주의 키/값 차원 변경, 계산량은 일정하게 유지:
  - 단일 헤드 주의는 최적 설정보다 0.9 BLEU 감소.
  - 너무 많은 헤드도 성능 저하 초래.
  
- (B) 주의 키 크기 dk 감소가 모델 품질 저하를 가져옴:
  - 복잡한 호환성 기능이 필요할 수 있음.

- (C) 및 (D) 큰 모델이 성능을 향상시키며, 드롭아웃이 과적합 방지에 유용하다는 사실 확인.

- (E) 삼각 함수 기반 위치 인코딩을 학습된 위치 인베딩으로 교체했으나 기본 모델과 유사한 결과 도출.

## 기타 성과
- Transformer는 영어 구성 구문 분석에서도 좋은 일반화 성능을 보여줌. 

- 다양한 기존 모델과 비교했을 때 Transformer는 높은 F1 점수를 기록함 (예: 4레이어 모델 91.3 F1).

---

# 6.3 English Constituency Parsing

- **목적**: Transformer 모델이 다른 작업에 일반화 가능한지 평가하기 위해 영어 구성 구문 분석 실험 수행
- **과제의 도전 과제**:
  - 출력은 강한 구조적 제약을 받음
  - 출력 길이가 입력 길이보다 상당히 길어짐
  - RNN 순차 모델은 소규모 데이터에서 최첨단 결과를 달성하지 못함
  
- **모델 구성**:
  - 4층 Transformer 모델 사용, 차원 dmodel = 1024
  - Wall Street Journal(WSJ) 부분의 Penn Treebank에서 약 40K 훈련 문장 사용
  - 반지도 학습 설정에도 사용, 약 1700만 문장의 고신뢰도 및 BerkleyParser 코퍼스 활용
  - WSJ만 사용할 경우 16K 토큰의 어휘, 반지도 설정에는 32K 토큰의 어휘 사용

- **실험 설정**:
  - 드롭아웃, 주의(attention) 및 잔여(residual) 파라미터, 학습률, 빔 크기 등의 소수 실험 수행
  - 나머지 파라미터는 영어-독일어 기본 번역 모델에서 변경하지 않음
  - 추론 시 최대 출력 길이를 입력 길이 + 300으로 설정
  - 빔 크기 21, α = 0.3 설정 (WSJ 및 반지도 설정 모두에서 적용)

- **결과**:
  - 모델이 과제 특화 조정이 없음에도 불구하고 매우 우수한 성능을 발휘
  - 이전에 보고된 모든 모델보다 더 좋은 성과를 내지만, 순환 신경망 문법 모델 제외
  - RNN 순차 모델과 비교할 때, Transformer가 WSJ 훈련 세트 40K 문장만으로도 Berkeley-Parser를 능가함

---

# 7 Conclusion

- Transformer 모델은 전적으로 주의(attention) 기반의 첫 번째 시퀀스 변환 모델.
- 인코더-디코더 구조의 순환 신경망 대신 다중 헤드 자기 주의(multi-headed self-attention) 사용.
- 번역 작업에서 Transformer는 순환 또는 컨볼루션 기반 아키텍처보다 훨씬 빠르게 훈련 가능.
- WMT 2014 영어-독일어 및 WMT 2014 영어-프랑스어 번역 작업에서 새로운 최첨단 성능 달성.
  - 영어-독일어 작업에서는 최선의 모델이 이전에 보고된 모든 앙상블을 초과 성능 기록.
- 주의 기반 모델의 미래에 대한 기대감.
  - 텍스트 이외의 입력 및 출력 양식에 적용 계획.
  - 이미지, 오디오, 비디오와 같은 대규모 입력과 출력을 효율적으로 처리하기 위한 제한된 주의 메커니즘 조사.
- 생성 과정을 덜 순차적으로 만드는 연구 목표 설정.

---

# 독자 의견

- 너무 유명한 Transformer 논문이고, 그냥 한번 요약해보았음.